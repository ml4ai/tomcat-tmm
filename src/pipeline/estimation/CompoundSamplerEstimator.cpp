#include "CompoundSamplerEstimator.h"

#include <iostream>

namespace tomcat {
    namespace model {

        using namespace std;

        //----------------------------------------------------------------------
        // Constructors & Destructor
        //----------------------------------------------------------------------
        CompoundSamplerEstimator::CompoundSamplerEstimator(
            const shared_ptr<DynamicBayesNet>& model,
            const shared_ptr<Sampler>& sampler,
            const std::shared_ptr<gsl_rng>& random_generator,
            int num_samples)
            : Estimator(model), sampler(sampler),
              random_generator(random_generator), num_samples(num_samples) {

            // Each data point will be used for estimation at a time.
            this->sampler->set_num_in_plate_samples(1);
            this->sampler->set_trainable(false);
        }

        CompoundSamplerEstimator::~CompoundSamplerEstimator() {}

        //----------------------------------------------------------------------
        // Copy & Move constructors/assignments
        //----------------------------------------------------------------------
        CompoundSamplerEstimator::CompoundSamplerEstimator(
            const CompoundSamplerEstimator& estimator) {
            Estimator::copy_estimator(estimator);
            this->copy_estimator(estimator);
        }

        CompoundSamplerEstimator& CompoundSamplerEstimator::operator=(
            const CompoundSamplerEstimator& estimator) {
            Estimator::copy_estimator(estimator);
            this->copy_estimator(estimator);
            return *this;
        }

        //----------------------------------------------------------------------
        // Member functions
        //----------------------------------------------------------------------
        void CompoundSamplerEstimator::copy(
            const CompoundSamplerEstimator& estimator) {
            this->next_time_step = estimator.next_time_step;
            this->sampler = estimator.sampler;
        }

        void CompoundSamplerEstimator::cleanup() {
            Estimator::cleanup();
            this->unfreeze_observable_nodes();
        }

        void CompoundSamplerEstimator::unfreeze_observable_nodes() {
            for (auto& [label, node] : this->nodes_to_unfreeze) {
                node->unfreeze();
            }

            this->nodes_to_unfreeze.clear();
        }

        void CompoundSamplerEstimator::prepare() {
            Estimator::prepare();
            this->next_time_step = 0;
            Estimator::cleanup();
            this->unfreeze_observable_nodes();
        }

        void CompoundSamplerEstimator::estimate(const EvidenceSet& new_data) {
            // Prevent the sampler from generating samples beyond the
            // inference horizon.
            this->sampler->set_max_time_step_to_sample(this->next_time_step +
                                                       this->inference_horizon);
            int time_steps = this->next_time_step + new_data.get_time_steps();
            for (int d = 0; d < new_data.get_num_data_points(); d++) {
                for (int t = this->next_time_step; t < time_steps; t++) {
                    EvidenceSet data = new_data.at(d, t - this->next_time_step);
                    this->add_data_to_nodes(data, t);
                    this->sampler->set_max_time_step_to_sample(
                        t + this->inference_horizon);
                    this->sampler->sample(this->random_generator,
                                          this->num_samples);

                    for (auto& estimator : this->estimators) {
                        // Use the samples generated by the sampler to compute
                        // concrete estimates
                        estimator.estimate(new_data);
                    }
                }
            }

            this->next_time_step = time_steps;
        }

        void
        CompoundSamplerEstimator::add_data_to_nodes(const EvidenceSet& new_data,
                                                    int time_step) {
            for (const auto& label : new_data.get_node_labels()) {
                Eigen::MatrixXd data = new_data[label](0, 0);
                const RVNodePtr node = dynamic_pointer_cast<RandomVariableNode>(
                    this->model->get_node(label, time_step));
                if (node) {
                    node->unfreeze();
                    node->set_assignment(data);
                    node->freeze();

                    // Include the node in the list of nodes to unfreeze
                    // at the end.
                    if (!EXISTS(label, this->nodes_to_unfreeze)) {
                        this->nodes_to_unfreeze[label] = node;
                    }
                }
            }
        }

        void CompoundSamplerEstimator::get_info(nlohmann::json& json) const {
            json["name"] = this->get_name();
            this->sampler->get_info(json["sampler"]);
        }

        string CompoundSamplerEstimator::get_name() const { return "sampler"; }

        void CompoundSamplerEstimator::add_estimator(
            const SamplerEstimator& estimator) {

            SamplerEstimator new_estimator = estimator;
            new_estimator.set_sampler(this->sampler);
            this->estimators.push_back(move(new_estimator));

            this->inference_horizon = max(
                this->inference_horizon, new_estimator.get_inference_horizon());
        }

    } // namespace model
} // namespace tomcat
