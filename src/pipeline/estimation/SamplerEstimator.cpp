#include "SamplerEstimator.h"

#include <iostream>

namespace tomcat {
    namespace model {

        using namespace std;

        //----------------------------------------------------------------------
        // Constructors & Destructor
        //----------------------------------------------------------------------
        // TODO - update sEstimator to receive a range
        SamplerEstimator::SamplerEstimator(
            const shared_ptr<DynamicBayesNet>& model,
            int inference_horizon,
            const std::string& node_label,
            const Eigen::VectorXd& low,
            const Eigen::VectorXd& high)
            : Estimator(model, inference_horizon, node_label, low) {}

        SamplerEstimator::~SamplerEstimator() {}

        //----------------------------------------------------------------------
        // Copy & Move constructors/assignments
        //----------------------------------------------------------------------
        SamplerEstimator::SamplerEstimator(const SamplerEstimator& estimator) {
            Estimator::copy_estimator(estimator);
            this->copy_estimator(estimator);
        }

        SamplerEstimator&
        SamplerEstimator::operator=(const SamplerEstimator& estimator) {
            Estimator::copy_estimator(estimator);
            this->copy_estimator(estimator);
            return *this;
        }

        //----------------------------------------------------------------------
        // Member functions
        //----------------------------------------------------------------------
        void SamplerEstimator::copy(const SamplerEstimator& estimator) {
            this->next_time_step = estimator.next_time_step;
            this->sampler = estimator.sampler;
        }

        void SamplerEstimator::prepare() {
            Estimator::prepare();
            this->next_time_step = 0;
        }

        void SamplerEstimator::estimate(const EvidenceSet& new_data) {
            // TODO - change this to retrieve just a slice
//            Eigen::MatrixXd samples =
//                this->sampler->get_samples(this->estimates.label)(0, 0);
//
//            if (this->estimates.assignment.size() > 0) {
//                Eigen::VectorXd matches =
//                    ((samples.array() == this->estimates.assignment(0))
//                         .rowwise()
//                         .sum() > 0);
//                double probability = matches.mean();
//
//                if (this->estimates.estimates.empty()) {
//                    this->estimates.estimates.push_back()
//                }
//
//                // Append to the list of estimates
//            }

//            this->estimates.estimates


            // Get samples generated by the sampler;
        }

        void SamplerEstimator::get_info(nlohmann::json& json) const {
            json["name"] = this->get_name();
            json["inference_horizon"] = this->inference_horizon;
            this->sampler->get_info(json["sampler"]);
        }

        string SamplerEstimator::get_name() const { return "sampler"; }

        void SamplerEstimator::set_sampler(const shared_ptr<Sampler>& sampler) {
            this->sampler = sampler;
        }

    } // namespace model
} // namespace tomcat
